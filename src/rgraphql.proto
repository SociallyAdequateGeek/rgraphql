syntax = "proto3";
package rgraphql;

message RGQLQueryFieldDirective {
  // Directive name
  string name = 1;
  // Optional arguments.
  repeated FieldArgument args = 2;
}

message RGQLQueryTreeNode {
  // Integer ID of the node.
  uint32 id = 1;
  // Name of the field this node represents.
  string field_name = 2;
  // Arguments.
  repeated FieldArgument args = 3;
  // Directives
  repeated RGQLQueryFieldDirective directive = 4;
  // Children
  repeated RGQLQueryTreeNode children = 5;
}

message FieldArgument {
  string name = 1;
  uint32 variable_id = 2;
}

message ASTVariable {
  uint32 id = 1;
  string json_value = 2;
}

// Messages
message RGQLClientMessage {
  RGQLTreeMutation mutate_tree = 1;
  // reserved 2
  RGQLSerialOperation serial_operation = 3;
}

message RGQLTreeMutation {
  // All node mutations in this step.
  repeated NodeMutation node_mutation = 1;
  // Any new variables.
  repeated ASTVariable variables = 2;

  message NodeMutation {
    // ID of the node we are operating on.
    uint32 node_id = 1;
    // Operation we are taking.
    SubtreeOperation operation = 2;
    // The new node tree to add, if we are adding a child.
    RGQLQueryTreeNode node = 3;
  }

  enum SubtreeOperation {
    // Add a child tree to the subtree.
    SUBTREE_ADD_CHILD = 0;
    // Delete a tree node and all children.
    SUBTREE_DELETE = 1;
  }
}

// A single serial operation, with a single response, like a mutation.
message RGQLSerialOperation {
  // The ID of this serial operation to use when communicating the result.
  uint32 operation_id = 1;
  // The type of this serial operation.
  SerialOperationType operation_type = 2;
  // All variables used in this operation.
  repeated ASTVariable variables = 3;
  // The query tree for the mutation.
  RGQLQueryTreeNode query_root = 4;

  // Types of serial operations available.
  enum SerialOperationType {
    MUTATION = 0;
  }
}

message RGQLServerMessage {
  RGQLValueMutation mutate_value = 1;
  RGQLQueryError query_error = 2;
  RGQLSerialResponse serial_response = 3;
}

message RGQLSerialResponse {
  // Operation ID specified in the request.
  uint32 operation_id = 1;
  // Response object.
  string response_json = 2;
  // Query error.
  RGQLQueryError query_error = 3;
  // Response error.
  RGQLSerialError resolve_error = 4;
}

// Communicating a failure in a serial request.
message RGQLSerialError {
  string error_json = 1;
}

// Communicating a failure in the input query.
message RGQLQueryError {
  uint32 query_node_id = 1;
  string error_json = 2;
}

message RGQLValueMutation {
  // The ID of the resolver execution (the value identifier).
  uint32 value_node_id = 1;
  // The ID of the parent resolver execution (the parent value identifier).
  uint32 parent_value_node_id = 2;
  // The ID of the query node (the query identifier).
  uint32 query_node_id = 3;
  // The operation on the value.
  ValueOperation operation = 4;
  // The actual value itself
  string value_json = 5;
  // Do we have a value to set?
  bool has_value = 6;
  // Is this a marker for an array?
  bool is_array = 7;

  enum ValueOperation {
    // Set/create the value of this resolver.
    VALUE_SET = 0;
    // Error this resolver (the value will enter the errored state).
    VALUE_ERROR = 1;
    // Delete this resolver
    VALUE_DELETE = 2;
  }
}
